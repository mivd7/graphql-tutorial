"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var path = require("path");
var fs_1 = require("fs");
var path_helpers_1 = require("./path-helpers");
function upperFirst(s) {
    return s.replace(/^\w/, function (c) { return c.toUpperCase(); });
}
exports.upperFirst = upperFirst;
/**
 * Support for different path notation
 *
 * './path/to/index.ts' => './path/to/index.ts'
 * './path/to' => './path/to/to.ts'
 * './path/to' => './path/to/index.ts'
 * './path/to/' => './path/to/index.ts'
 */
function normalizeFilePath(filePath, language) {
    var ext = path_helpers_1.getExtNameFromLanguage(language);
    if (path.extname(filePath) !== ext) {
        var pathToFileWithExt = path.resolve(filePath) + ext;
        if (fs_1.existsSync(pathToFileWithExt)) {
            return pathToFileWithExt;
        }
        return path.join(path.resolve(filePath), 'index' + ext);
    }
    return path.resolve(filePath);
}
exports.normalizeFilePath = normalizeFilePath;
/**
 * Create a map of interface names to the path of the file in which they're defined
 * The first evaluated interfaces are always the chosen ones
 */
function getTypeToFileMapping(files, filesToTypesMap) {
    return files.reduce(function (acc, file) {
        var typesMap = filesToTypesMap[file.path];
        var interfaceNames = Object.keys(typesMap).filter(function (interfaceName) { return !acc[interfaceName]; });
        interfaceNames.forEach(function (interfaceName) {
            acc[interfaceName] = file;
        });
        return acc;
    }, {});
}
exports.getTypeToFileMapping = getTypeToFileMapping;
function replaceAll(str, search, replacement) {
    return str.split(search).join(replacement);
}
exports.replaceAll = replaceAll;
function flatten(a, b) {
    return a.concat(b);
}
exports.flatten = flatten;
function uniq(value, index, array) {
    return array.indexOf(value) === index;
}
exports.uniq = uniq;
//# sourceMappingURL=utils.js.map