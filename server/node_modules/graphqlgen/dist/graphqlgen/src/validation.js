"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var chalk_1 = require("chalk");
var path = require("path");
var fs_1 = require("fs");
var path_helpers_1 = require("./path-helpers");
var ast_1 = require("./ast");
var source_helper_1 = require("./source-helper");
var output_1 = require("./output");
function validateConfig(config, schema) {
    var language = config.language;
    if (!validateContext(config.context, language)) {
        return false;
    }
    if (!validateModelMap(config.models, schema, language)) {
        return false;
    }
    return true;
}
exports.validateConfig = validateConfig;
function validateContext(contextDefinition, language) {
    if (!contextDefinition) {
        return true;
    }
    var validatedContext = validateDefinition('Context', contextDefinition, language);
    if (!validatedContext.validSyntax) {
        console.log(chalk_1.default.redBright("Invalid context: '" + chalk_1.default.bold(validatedContext.definition.rawDefinition) + "' does not follow '" + chalk_1.default.bold('context: <filePath>:<interfaceName>') + "' syntax)"));
        return false;
    }
    if (!validatedContext.fileExists) {
        console.log(chalk_1.default.redBright("Invalid context: file '" + chalk_1.default.bold(validatedContext.definition.filePath) + "' not found"));
        return false;
    }
    if (!validatedContext.interfaceExists) {
        console.log(chalk_1.default.redBright("Invalid context: interface '" + chalk_1.default.bold(validatedContext.definition.modelName) + "' not found in file '" + chalk_1.default.bold(validatedContext.definition.filePath) + "'"));
        return false;
    }
    return true;
}
function validateModelMap(modelsConfig, schema, language) {
    var validatedDefinitions = Object.keys(modelsConfig).map(function (typeName) {
        return validateDefinition(typeName, modelsConfig[typeName], language);
    });
    // Check whether the syntax in correct
    if (validatedDefinitions.some(function (validation) { return !validation.validSyntax; })) {
        output_1.outputWrongSyntaxFiles(validatedDefinitions);
        return false;
    }
    // Check whether the model file exist
    if (validatedDefinitions.some(function (validation) { return !validation.fileExists; })) {
        output_1.outputDefinitionFilesNotFound(validatedDefinitions);
        return false;
    }
    // Check whether the interface inside the model file exist
    if (validatedDefinitions.some(function (validation) { return !validation.interfaceExists; })) {
        output_1.outputInterfaceDefinitionsNotFound(validatedDefinitions);
        return false;
    }
    // Check whether there's a 1-1 mapping between schema types and models
    if (!validateSchemaToModelMapping(schema, validatedDefinitions)) {
        return false;
    }
    return true;
}
function validateSchemaToModelMapping(schema, validatedDefinitions) {
    var types = source_helper_1.extractGraphQLTypes(schema);
    var typeNames = validatedDefinitions.map(function (def) { return def.definition.typeName; });
    var missingModels = types
        .filter(function (type) { return ['Query', 'Mutation', 'Subscription'].indexOf(type.name) === -1; })
        .filter(function (type) { return !typeNames.find(function (typeName) { return typeName === type.name; }); });
    if (missingModels.length > 0) {
        output_1.outputMissingModels(missingModels);
        return false;
    }
    return true;
}
/**
 * Support for different path notation
 *
 * './path/to/index.ts' => './path/to/index.ts'
 * './path/to' => './path/to/index.ts'
 * './path/to/' => './path/to/index.ts'
 */
function normalizeFilePath(filePath, language) {
    var ext = path_helpers_1.getExtNameFromLanguage(language);
    if (path.extname(filePath) !== ext) {
        return path.join(filePath, 'index' + ext);
    }
    return filePath;
}
function hasInterfaceInTypescriptFile(filePath, interfaceName) {
    return !!ast_1.findInterfaceByName(filePath, interfaceName);
}
// Check whether the model definition exists in typescript/flow file
function interfaceDefinitionExistsInFile(filePath, modelName, language) {
    switch (language) {
        case 'typescript':
            return hasInterfaceInTypescriptFile(filePath, modelName);
    }
}
function validateDefinition(typeName, definition, language) {
    var validation = {
        definition: {
            typeName: typeName,
            rawDefinition: definition,
        },
        validSyntax: true,
        fileExists: true,
        interfaceExists: true,
    };
    if (definition.split(':').length !== 2) {
        validation.validSyntax = false;
        validation.fileExists = false;
        validation.interfaceExists = false;
        return validation;
    }
    var _a = definition.split(':'), filePath = _a[0], modelName = _a[1];
    validation.definition.filePath = filePath;
    validation.definition.modelName = modelName;
    var normalizedFilePath = normalizeFilePath(filePath, language);
    if (!fs_1.existsSync(normalizedFilePath)) {
        validation.fileExists = false;
        validation.interfaceExists = false;
        return validation;
    }
    if (!interfaceDefinitionExistsInFile(normalizedFilePath, modelName, language)) {
        validation.interfaceExists = false;
    }
    return validation;
}
exports.validateDefinition = validateDefinition;
//# sourceMappingURL=validation.js.map