"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var os = require("os");
var source_helper_1 = require("../source-helper");
var utils_1 = require("../utils");
var utils_2 = require("../introspection/utils");
function fieldsFromModelDefinition(modelDef) {
    // If model is of type `interface InterfaceName { ... }`
    if (modelDef.kind === 'InterfaceDefinition') {
        var interfaceDef = modelDef;
        return interfaceDef.fields;
    }
    // If model is of type `type TypeName = { ... }`
    if (modelDef.kind === 'TypeAliasDefinition' &&
        modelDef.getType().kind ===
            'AnonymousInterfaceAnnotation') {
        var interfaceDef = modelDef.getType();
        return interfaceDef.fields;
    }
    return [];
}
exports.fieldsFromModelDefinition = fieldsFromModelDefinition;
function renderDefaultResolvers(graphQLTypeObject, args, variableName) {
    var model = args.modelMap[graphQLTypeObject.name];
    if (model === undefined) {
        return "export const " + variableName + " = {}";
    }
    var modelDef = model.definition;
    return "export const " + variableName + " = {\n    " + fieldsFromModelDefinition(modelDef)
        .filter(function (modelField) {
        var graphQLField = graphQLTypeObject.fields.find(function (field) { return field.name === modelField.name; });
        return shouldRenderDefaultResolver(graphQLField, modelField, args);
    })
        .map(function (modelField) {
        return renderDefaultResolver(modelField.name, modelField.optional, model.definition.name);
    })
        .join(os.EOL) + "\n  }";
}
exports.renderDefaultResolvers = renderDefaultResolvers;
function renderDefaultResolver(fieldName, fieldOptional, parentTypeName) {
    var field = "parent." + fieldName;
    var fieldGetter = renderFieldGetter(field, fieldOptional);
    return fieldName + ": (parent: " + parentTypeName + ") => " + fieldGetter + ",";
}
function renderFieldGetter(fieldGetter, fieldOptional) {
    if (fieldOptional) {
        return fieldGetter + " === undefined ? null : " + fieldGetter;
    }
    return fieldGetter;
}
function getContextName(context) {
    if (!context) {
        return 'Context';
    }
    return context.interfaceName;
}
exports.getContextName = getContextName;
function getModelName(type, modelMap, emptyType) {
    if (emptyType === void 0) { emptyType = '{}'; }
    var model = modelMap[type.name];
    if (type.isEnum) {
        return type.name;
    }
    // NOTE if no model is found, return the empty type
    // It's usually assumed that every GraphQL type has a model associated
    // expect for the `Query`, `Mutation` and `Subscription` type
    if (model === undefined) {
        return emptyType;
    }
    return model.definition.name;
}
exports.getModelName = getModelName;
function isModelEnumSubsetOfGraphQLEnum(graphQLEnumValues, modelEnumValues) {
    return modelEnumValues.every(function (enumValue) {
        return graphQLEnumValues.includes(enumValue);
    });
}
function shouldRenderDefaultResolver(graphQLField, modelField, args) {
    if (graphQLField === undefined) {
        return false;
    }
    if (modelField === undefined) {
        return false;
    }
    var modelFieldType = modelField.getType();
    // If both types are enums, and model definition enum is a subset of the graphql enum
    // Then render as defaultResolver
    // eg: given GraphQLEnum = 'A' | 'B' | 'C'
    // render when FieldDefinition = ('A') | ('A' | 'B') | ('A | 'B' | 'C')
    if (graphQLField.type.isEnum &&
        utils_2.isFieldDefinitionEnumOrLiteral(modelFieldType)) {
        return isModelEnumSubsetOfGraphQLEnum(source_helper_1.getGraphQLEnumValues(graphQLField, args.enums), utils_2.getEnumValues(modelFieldType));
    }
    return !(modelField.optional && graphQLField.type.isRequired);
}
function shouldScaffoldFieldResolver(graphQLField, modelFields, args) {
    var modelField = modelFields.find(function (modelField) { return modelField.name === graphQLField.name; });
    return !shouldRenderDefaultResolver(graphQLField, modelField, args);
}
exports.shouldScaffoldFieldResolver = shouldScaffoldFieldResolver;
function printFieldLikeType(field, modelMap) {
    if (field.type.isScalar) {
        return "" + getTypeFromGraphQLType(field.type.name) + (field.type.isArray ? '[]' : '') + (!field.type.isRequired ? '| null' : '');
    }
    if (field.type.isInput || field.type.isEnum) {
        return "" + field.type.name + (field.type.isArray ? '[]' : '') + (!field.type.isRequired ? '| null' : '');
    }
    return "" + getModelName(field.type, modelMap) + (field.type.isArray ? '[]' : '') + (!field.type.isRequired ? '| null' : '');
}
exports.printFieldLikeType = printFieldLikeType;
function getTypeFromGraphQLType(type) {
    if (type === 'Int' || type === 'Float') {
        return 'number';
    }
    if (type === 'Boolean') {
        return 'boolean';
    }
    if (type === 'String' || type === 'ID' || type === 'DateTime') {
        return 'string';
    }
    return 'string';
}
exports.getTypeFromGraphQLType = getTypeFromGraphQLType;
function deepResolveInputTypes(inputTypesMap, typeName, seen) {
    if (seen === void 0) { seen = {}; }
    var type = inputTypesMap[typeName];
    if (type) {
        var childTypes = type.fields
            .filter(function (t) { return t.type.isInput && !seen[t.type.name]; })
            .map(function (t) { return t.type.name; })
            .map(function (name) {
            var _a;
            return deepResolveInputTypes(inputTypesMap, name, __assign({}, seen, (_a = {}, _a[name] = true, _a)));
        })
            .reduce(utils_1.flatten, []);
        return [typeName].concat(childTypes);
    }
    else {
        throw new Error("Input type " + typeName + " not found");
    }
}
function getDistinctInputTypes(type, typeToInputTypeAssociation, inputTypesMap) {
    return typeToInputTypeAssociation[type.name]
        .map(function (t) { return deepResolveInputTypes(inputTypesMap, t); })
        .reduce(utils_1.flatten, [])
        .filter(utils_1.uniq);
}
exports.getDistinctInputTypes = getDistinctInputTypes;
function renderEnums(args) {
    return args.enums
        .map(function (enumObject) {
        return "type " + enumObject.name + " = " + enumObject.values
            .map(function (value) { return "'" + value + "'"; })
            .join(' | ');
    })
        .join(os.EOL);
}
exports.renderEnums = renderEnums;
function isParentType(name) {
    var parentTypes = ['Query', 'Mutation', 'Subscription'];
    return parentTypes.indexOf(name) > -1;
}
exports.isParentType = isParentType;
function groupModelsNameByImportPath(models) {
    return models.reduce(function (acc, model) {
        if (acc[model.importPathRelativeToOutput] === undefined) {
            acc[model.importPathRelativeToOutput] = [];
        }
        acc[model.importPathRelativeToOutput].push(model.definition.name);
        return acc;
    }, {});
}
exports.groupModelsNameByImportPath = groupModelsNameByImportPath;
//# sourceMappingURL=common.js.map