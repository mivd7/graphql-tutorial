"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = require("./common");
var ts_generator_1 = require("./ts-generator");
exports.format = ts_generator_1.format;
function renderResolvers(type, args) {
    var model = args.modelMap[type.name];
    var modelFields = common_1.fieldsFromModelDefinition(model.definition);
    var code = "  // This resolver file was scaffolded by github.com/prisma/graphqlgen, DO NOT EDIT.\n  // Please do not import this file directly but copy & paste to your application code.\n\n  import { " + type.name + "Resolvers } from '[TEMPLATE-INTERFACES-PATH]'\n\n  export const " + type.name + ": " + type.name + "Resolvers.Type = {\n    ..." + type.name + "Resolvers.defaultResolvers,\n    " + type.fields
        .filter(function (field) { return common_1.shouldScaffoldFieldResolver(field, modelFields, args); })
        .map(function (field) { return "\n      " + field.name + ": (parent, args, ctx) => {\n        throw new Error('Resolver not implemented')\n      }\n    "; }) + "\n  }";
    return { path: type.name + ".ts", force: false, code: code };
}
function renderParentResolvers(type) {
    var code = "  // This resolver file was scaffolded by github.com/prisma/graphqlgen, DO NOT EDIT.\n  // Please do not import this file directly but copy & paste to your application code.\n\n  import { " + type.name + "Resolvers } from '[TEMPLATE-INTERFACES-PATH]'\n  \n  export const " + type.name + ": " + type.name + "Resolvers.Type = {\n    ..." + type.name + "Resolvers.defaultResolvers,\n    " + type.fields.map(function (field) {
        if (type.name === 'Subscription') {
            return field.name + ": {\n          subscribe: (parent, args, ctx) => {\n            throw new Error('Resolver not implemented')\n          }\n        }";
        }
        return field.name + ": (parent, args, ctx) => {\n          throw new Error('Resolver not implemented')\n        }";
    }) + "\n  }\n      ";
    return {
        path: type.name + ".ts",
        force: false,
        code: code,
    };
}
function renderExports(types) {
    return "  // This resolver file was scaffolded by github.com/prisma/graphqlgen, DO NOT EDIT.\n  // Please do not import this file directly but copy & paste to your application code.\n\n  import { Resolvers } from '[TEMPLATE-INTERFACES-PATH]'\n    " + types
        .filter(function (type) { return type.type.isObject; })
        .map(function (type) { return "\n      import { " + type.name + " } from './" + type.name + "'\n    "; })
        .join(';') + "\n\n    export const resolvers: Resolvers = {\n      " + types
        .filter(function (type) { return type.type.isObject; })
        .map(function (type) { return "" + type.name; })
        .join(',') + "\n    }";
}
function generate(args) {
    var files = args.types
        .filter(function (type) { return type.type.isObject; })
        .filter(function (type) { return !common_1.isParentType(type.name); })
        .map(function (type) { return renderResolvers(type, args); });
    files = files.concat(args.types
        .filter(function (type) { return type.type.isObject; })
        .filter(function (type) { return common_1.isParentType(type.name); })
        .map(renderParentResolvers));
    files.push({
        path: 'index.ts',
        force: false,
        code: renderExports(args.types),
    });
    return files;
}
exports.generate = generate;
//# sourceMappingURL=ts-scaffolder.js.map