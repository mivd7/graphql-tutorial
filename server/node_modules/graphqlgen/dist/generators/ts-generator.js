"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var os = require("os");
var prettier = require("prettier");
var common_1 = require("./common");
var utils_1 = require("../utils");
function format(code, options) {
    if (options === void 0) { options = {}; }
    try {
        return prettier.format(code, __assign({}, options, { parser: 'typescript' }));
    }
    catch (e) {
        console.log("There is a syntax error in generated code, unformatted code printed, error: " + JSON.stringify(e));
        return code;
    }
}
exports.format = format;
function generate(args) {
    // TODO: Maybe move this to source helper
    var inputTypesMap = args.types
        .filter(function (type) { return type.type.isInput; })
        .reduce(function (inputTypes, type) {
        var _a;
        return __assign({}, inputTypes, (_a = {}, _a["" + type.name] = type, _a));
    }, {});
    // TODO: Type this
    var typeToInputTypeAssociation = args.types
        .filter(function (type) {
        return type.type.isObject &&
            type.fields.filter(function (field) { return field.arguments.filter(function (arg) { return arg.type.isInput; }).length > 0; }).length > 0;
    })
        .reduce(function (types, type) {
        var _a;
        return __assign({}, types, (_a = {}, _a["" + type.name] = [].concat.apply([], type.fields.map(function (field) {
            return field.arguments
                .filter(function (arg) { return arg.type.isInput; })
                .map(function (arg) { return arg.type.name; });
        })), _a));
    }, {});
    return "  " + renderHeader(args) + "\n  \n  " + common_1.renderEnums(args) + "\n\n  " + renderNamespaces(args, typeToInputTypeAssociation, inputTypesMap) + "\n\n  " + renderResolvers(args) + "\n\n  ";
}
exports.generate = generate;
function renderHeader(args) {
    var modelsToImport = Object.keys(args.modelMap)
        .filter(function (modelName) {
        var modelDef = args.modelMap[modelName].definition;
        return !(modelDef.kind === 'TypeAliasDefinition' &&
            modelDef.isEnum);
    })
        .map(function (modelName) { return args.modelMap[modelName]; });
    var modelsByImportPaths = common_1.groupModelsNameByImportPath(modelsToImport);
    var modelImports = Object.keys(modelsByImportPaths)
        .map(function (importPath) {
        return "import { " + modelsByImportPaths[importPath].join(', ') + " } from '" + importPath + "'";
    })
        .join(os.EOL);
    return "\n// Code generated by github.com/prisma/graphqlgen, DO NOT EDIT.\n\nimport { GraphQLResolveInfo } from 'graphql'\n" + modelImports + "\n" + renderContext(args.context) + "\n  ";
}
function renderContext(context) {
    if (context) {
        return "import { " + common_1.getContextName(context) + " } from '" + context.contextPath + "'";
    }
    return "type " + common_1.getContextName(context) + " = any";
}
function renderNamespaces(args, typeToInputTypeAssociation, inputTypesMap) {
    return args.types
        .filter(function (type) { return type.type.isObject; })
        .map(function (type) {
        return renderNamespace(type, typeToInputTypeAssociation, inputTypesMap, args);
    })
        .join(os.EOL);
}
function renderNamespace(graphQLTypeObject, typeToInputTypeAssociation, inputTypesMap, args) {
    return "    export namespace " + graphQLTypeObject.name + "Resolvers {\n\n    " + common_1.renderDefaultResolvers(graphQLTypeObject, args, 'defaultResolvers') + "\n\n    " + renderInputTypeInterfaces(graphQLTypeObject, args.modelMap, typeToInputTypeAssociation, inputTypesMap) + "\n\n    " + renderInputArgInterfaces(graphQLTypeObject, args.modelMap) + "\n\n    " + renderResolverFunctionInterfaces(graphQLTypeObject, args.modelMap, args.context) + "\n\n    " + renderResolverTypeInterface(graphQLTypeObject, args.modelMap, args.context) + "\n\n    " + '' + "\n  }\n  ";
}
function renderInputTypeInterfaces(type, modelMap, typeToInputTypeAssociation, inputTypesMap) {
    if (!typeToInputTypeAssociation[type.name]) {
        return "";
    }
    return common_1.getDistinctInputTypes(type, typeToInputTypeAssociation, inputTypesMap)
        .map(function (typeAssociation) {
        return "export interface " + inputTypesMap[typeAssociation].name + " {\n      " + inputTypesMap[typeAssociation].fields.map(function (field) { return field.name + ": " + common_1.printFieldLikeType(field, modelMap); }) + "\n    }";
    })
        .join(os.EOL);
}
function renderInputArgInterfaces(type, modelMap) {
    return type.fields
        .map(function (field) { return renderInputArgInterface(field, modelMap); })
        .join(os.EOL);
}
function renderInputArgInterface(field, modelMap) {
    if (field.arguments.length === 0) {
        return '';
    }
    return "\n  export interface Args" + utils_1.upperFirst(field.name) + " {\n    " + field.arguments
        .map(function (arg) {
        return arg.name + ": " + common_1.printFieldLikeType(arg, modelMap);
    })
        .join(os.EOL) + "\n  }\n  ";
}
function renderResolverFunctionInterfaces(type, modelMap, context) {
    return type.fields
        .map(function (field) {
        return renderResolverFunctionInterface(field, type, modelMap, context);
    })
        .join(os.EOL);
}
function renderResolverFunctionInterface(field, type, modelMap, context) {
    var resolverName = utils_1.upperFirst(field.name) + "Resolver";
    var resolverDefinition = "\n  (\n    parent: " + common_1.getModelName(type.type, modelMap, 'undefined') + ",\n    args: " + (field.arguments.length > 0 ? "Args" + utils_1.upperFirst(field.name) : '{}') + ",\n    ctx: " + common_1.getContextName(context) + ",\n    info: GraphQLResolveInfo,\n  )\n  ";
    var returnType = common_1.printFieldLikeType(field, modelMap);
    if (type.name === 'Subscription') {
        return "\n    export type " + resolverName + " = {\n      subscribe: " + resolverDefinition + " => AsyncIterator<" + returnType + "> | Promise<AsyncIterator<" + returnType + ">>\n      resolve?: " + resolverDefinition + " => " + returnType + " | Promise<" + returnType + ">\n    }\n    ";
    }
    return "\n  export type " + resolverName + " = " + resolverDefinition + " => " + returnType + " | Promise<" + returnType + ">\n  ";
}
function renderResolverTypeInterface(type, modelMap, context) {
    return "\n  export interface Type {\n    " + type.fields
        .map(function (field) {
        return renderResolverTypeInterfaceFunction(field, type, modelMap, context);
    })
        .join(os.EOL) + "\n  }\n  ";
}
function renderResolverTypeInterfaceFunction(field, type, modelMap, context) {
    var resolverDefinition = "\n  (\n    parent: " + common_1.getModelName(type.type, modelMap, 'undefined') + ",\n    args: " + (field.arguments.length > 0 ? "Args" + utils_1.upperFirst(field.name) : '{}') + ",\n    ctx: " + common_1.getContextName(context) + ",\n    info: GraphQLResolveInfo,\n  )\n  ";
    var returnType = common_1.printFieldLikeType(field, modelMap);
    if (type.name === 'Subscription') {
        return "\n    " + field.name + ": {\n      subscribe: " + resolverDefinition + " => AsyncIterator<" + returnType + "> | Promise<AsyncIterator<" + returnType + ">>\n      resolve?: " + resolverDefinition + " => " + returnType + " | Promise<" + returnType + ">\n    }\n    ";
    }
    return "\n    " + field.name + ": " + resolverDefinition + " => " + returnType + " | Promise<" + returnType + ">\n  ";
}
function renderResolvers(args) {
    return "\nexport interface Resolvers {\n  " + args.types
        .filter(function (type) { return type.type.isObject; })
        .map(function (type) { return type.name + ": " + type.name + "Resolvers.Type"; })
        .join(os.EOL) + "\n}\n  ";
}
//# sourceMappingURL=ts-generator.js.map