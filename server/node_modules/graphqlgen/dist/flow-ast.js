"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var fs = require("fs");
var parser_1 = require("@babel/parser");
var parse_1 = require("./parse");
function getSourceFile(filePath) {
    var file = fs.readFileSync(filePath).toString('utf-8');
    return parser_1.parse(file, { plugins: ['flow'] });
}
function shouldExtractType(node) {
    return node.type === 'TypeAlias' || node.type === 'InterfaceDeclaration';
}
function getFlowTypes(sourceFile) {
    var statements = sourceFile.program.body;
    var types = statements.filter(shouldExtractType);
    var typesFromNamedExport = statements
        .filter(function (node) {
        return node.type === 'ExportNamedDeclaration' &&
            node.declaration !== null &&
            shouldExtractType(node.declaration);
    })
        .map(function (node) {
        return node.declaration;
    });
    return types.concat(typesFromNamedExport);
}
function findFlowTypeByName(filePath, typeName) {
    var sourceFile = getSourceFile(filePath);
    return getFlowTypes(sourceFile).find(function (node) { return node.id.name === typeName; });
}
exports.findFlowTypeByName = findFlowTypeByName;
function typeNamesFromFlowFile(file) {
    var filePath = parse_1.getPath(file);
    var sourceFile = getSourceFile(filePath);
    return getFlowTypes(sourceFile).map(function (node) { return node.id.name; });
}
exports.typeNamesFromFlowFile = typeNamesFromFlowFile;
function isFieldOptional(node) {
    if (!!node.optional) {
        return true;
    }
    if (node.value.type === 'NullLiteralTypeAnnotation') {
        return true;
    }
    if (node.value.type === 'UnionTypeAnnotation') {
        return node.value.types.some(function (unionType) { return unionType.type === 'NullLiteralTypeAnnotation'; });
    }
    return false;
}
function extractFieldsFromFlowType(model) {
    var filePath = model.absoluteFilePath;
    var typeNode = findFlowTypeByName(filePath, model.modelTypeName);
    if (!typeNode) {
        throw new Error("No interface found for name " + model.modelTypeName);
    }
    var childrenNodes = typeNode.type === 'TypeAlias'
        ? typeNode.right
        : typeNode.body;
    return childrenNodes.properties
        .filter(function (childNode) { return childNode.type === 'ObjectTypeProperty'; })
        .map(function (childNode) {
        var childNodeProperty = childNode;
        var fieldName = childNodeProperty.key.name;
        var fieldOptional = isFieldOptional(childNodeProperty);
        return { fieldName: fieldName, fieldOptional: fieldOptional };
    });
}
exports.extractFieldsFromFlowType = extractFieldsFromFlowType;
//# sourceMappingURL=flow-ast.js.map